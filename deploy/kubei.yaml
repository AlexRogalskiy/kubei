---
apiVersion: v1
kind: Namespace
metadata:
  name: kubei
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: kubei
  namespace: kubei
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: kubei
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["list"]
- apiGroups: ["batch"]
  resources: ["jobs"]
  verbs: ["create","delete"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: kubei
subjects:
- kind: ServiceAccount
  name: kubei
  namespace: kubei
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: kubei
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: grype-server
  namespace: kubei
  labels:
    app: grype-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app: grype-server
  template:
    metadata:
      labels:
        app: grype-server
        kubeiShouldScan: "false"
    spec:
      containers:
      - name: grype-server
        image: gcr.io/eticloud/k8sec/grype-server:2.1.6
        args:
          - run
          - --log-level
          - warning
        env:
          - name: DB_ROOT_DIR
            value: "/tmp/"
        imagePullPolicy: Always
        ports:
        - containerPort: 9991
        resources:
          limits:
            cpu: 1000m
            memory: 1G
          requests:
            cpu: 200m
            memory: 200Mi
# uncomment the following lines in case Kubei is running behind proxy. update PROXY_IP & PROXY_PORT according to your proxy settings
#        env:
#        - name: HTTPS_PROXY
#          value: "{ PROXY_IP }:{ PROXY_PORT }"
#        - name: HTTP_PROXY
#          value: "{ PROXY_IP }:{ PROXY_PORT }"
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: grype-server
  name: grype-server
  namespace: kubei
spec:
  type: ClusterIP
  ports:
    - name: grype-server
      port: 9991
      protocol: TCP
  selector:
    app: grype-server
---
apiVersion: v1
kind: Service
metadata:
  namespace: kubei
  name: kubei
  labels:
    app: kubei
spec:
  type: ClusterIP
  ports:
  - port: 8080
    protocol: TCP
    name: http-webapp
  - port: 8081
    protocol: TCP
    name: http-klar-result
  selector:
    app: kubei
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kubei
  namespace: kubei
  labels:
    app: kubei
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kubei
  template:
    metadata:
      labels:
        app: kubei
        kubeiShouldScan: "false"
    spec:
      serviceAccountName: kubei
      containers:
      - name: kubei
        image: gcr.io/eticloud/k8sec/kubei:1.0.13
        imagePullPolicy: Always
        env:
        - name: "KLAR_IMAGE_NAME"
          value: "gcr.io/eticloud/k8sec/klar:1.0.17"
        - name: "DOCKLE_IMAGE_NAME"
          value: "gcr.io/eticloud/k8sec/dockle:1.0.4"
        - name: "MAX_PARALLELISM" # max number of scans that will run simultaneously. defaults to 10
          value: "10"
        - name: "TARGET_NAMESPACE" # empty = scan all namespaces
          value: ""
        - name: "SEVERITY_THRESHOLD" # minimum level of vulnerability to report. defaults to MEDIUM
          value: "MEDIUM"
        - name: "IGNORE_NAMESPACES" # a list of namespaces to ignore. defaults no namespace to ignore
          value: "istio-system,kube-system"
        - name: "DELETE_JOB_POLICY"
          value: "Successful"
        - name: "SCANNER_SERVICE_ACCOUNT" # Defaults to 'default' service account
          value: ""
        - name: "REGISTRY_INSECURE" # Allow scanner to access insecure registries (HTTP only). Default is `false`.
          value: "false"
# uncomment the following lines in case Kubei is running behind proxy. update PROXY_IP & PROXY_PORT according to your proxy settings
#        - name: SCANNER_HTTPS_PROXY
#          value: "{ PROXY_IP }:{ PROXY_PORT }"
#        - name: SCANNER_HTTP_PROXY
#          value: "{ PROXY_IP }:{ PROXY_PORT }"
        ports:
        - containerPort: 8080
        - containerPort: 8081
        resources:
          limits:
            cpu: 100m
            memory: 100Mi
          requests:
            cpu: 10m
            memory: 20Mi
